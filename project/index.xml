<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects | Adam Jelley</title><link>https://adamjelley.github.io/project/</link><atom:link href="https://adamjelley.github.io/project/index.xml" rel="self" type="application/rss+xml"/><description>Projects</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Â© 2024 Adam Jelley</copyright><lastBuildDate>Sun, 01 Dec 2024 00:00:00 +0000</lastBuildDate><image><url>https://adamjelley.github.io/media/icon_hudb77e0d6599affbdab246cf9ea514ec9_35945_512x512_fill_lanczos_center_3.png</url><title>Projects</title><link>https://adamjelley.github.io/project/</link></image><item><title>Nand2Tetris</title><link>https://adamjelley.github.io/project/nand2tetris/</link><pubDate>Sun, 01 Dec 2024 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/nand2tetris/</guid><description>&lt;p>My code for the renown &lt;a href="%28https://www.nand2tetris.org%29">Nand2Tetris&lt;/a> course, culminating in the Breakout game shown below, running on the computational stack designed and implemented in &lt;a href="https://github.com/AdamJelley/Nand2Tetris" target="_blank" rel="noopener">this repository&lt;/a>.&lt;/p>
&lt;img src="../../uploads/BreakoutDemo.mp4" alt="Demo of Breakout game running on Hack computer.">
&lt;p>The course goes through building a simple general purpose computer, from elementary switching gates (NAND gates) to high-level object-oriented software engineering, resulting in a hardware platform and software hierarchy capable of implementing arbitrary programs, such as Tetris (or in my case, &lt;a href="https://en.wikipedia.org/wiki/Breakout_%28video_game%29" target="_blank" rel="noopener">Breakout&lt;/a>). The aim is to provide hands-on knowledge of hardware, architecture, operating systems, programming languages, compilers, software engineering and relevant algorithms and data structures.&lt;/p>
&lt;p>I embarked on this course during a difficult time during my PhD, thanks to a recommendation from my good friend &lt;a href="https://eloialonso.github.io" target="_blank" rel="noopener">Eloi&lt;/a>. I later chose to implement the game Breakout in part because this was the main game we used for the development of &lt;a href="https://adamjelley.github.io/publication/diamond/" target="_blank" rel="noopener">DIAMOND&lt;/a>. I envisioned one day implementing a &lt;a href="https://github.com/karpathy/micrograd" target="_blank" rel="noopener">minimal auto-differentiation package&lt;/a> and running &lt;a href="https://adamjelley.github.io/publication/diamond/" target="_blank" rel="noopener">DIAMOND&lt;/a> (or at least a &lt;a href="https://adamjelley.github.io/project/rlimplementations/" target="_blank" rel="noopener">DQN agent&lt;/a>) on the Hack computer, but I suspect I might struggle to find the time for that now&amp;hellip; The full course took me over a year to complete in the background of my PhD work, but thankfully helped me to find the fun in computers again, so was well-worth the time and is highly recommended.&lt;/p>
&lt;p>Check out the Nand2Tetris &lt;a href="https://www.nand2tetris.org" target="_blank" rel="noopener">website&lt;/a> and accompanying textbook, &lt;a href="https://www.amazon.co.uk/Elements-Computing-Systems-second-Principles-ebook/dp/B084V7R8PT/ref=tmm_kin_swatch_0" target="_blank" rel="noopener">&lt;em>The Elements of Computing Systems: Building a Modern Computer from First Principles&lt;/em>&lt;/a> for more information.&lt;/p>
&lt;h2 id="course-syllabus">Course Syllabus:&lt;/h2>
&lt;h3 id="part-i-hardware">Part I: Hardware&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Project 1: Boolean Logic&lt;/strong>
&lt;ul>
&lt;li>Designing a set of 15 elementary logic gates from primative NAND gates using a simple Hardware Description Language (HDL).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 2: Boolean Arithmetic&lt;/strong>
&lt;ul>
&lt;li>Combining the elementary logic gates designed in Project 1 into more complex chips, namely a simple Arithmetic Logic Unit (ALU), capable of performing arithmetic and logical operations. The ALU is later used as a core component of the computer&amp;rsquo;s Central Processing Unit (CPU).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 3: Sequential Logic&lt;/strong>
&lt;ul>
&lt;li>Building a hierarchy of memory chips, from elementary flip-flop gates into n-bit registers and eventually Random Access Memory (RAM) chips. Unlike processing chips which use combinatorial Boolean logic, these chips use clock-based sequential logic.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 4: Machine Language&lt;/strong>
&lt;ul>
&lt;li>Writing low-level assembly programs in the Hack machine language, capable of multiplication and memory operations to develop an understanding of what will be required from the Hack computer.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 5: Computer Architecture&lt;/strong>
&lt;ul>
&lt;li>Integrating the earlier ALU and memory chips into a general-purpose 16-bit computer called Hack. The ALU is combined with A, D and M registers and a program counter (PC) to form the Central Processing Unit (CPU), which is then combined with RAM (Random Access Memory) and ROM (Read-Only Memory) to form the Hack computer.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 6: Assembler&lt;/strong>
&lt;ul>
&lt;li>Building the Assembler, which translates the symbolic machine language (assembly code) into binary code (a time-series of 16-bit input) which can be run directly on the Hack computer.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="part-ii-software">Part II: Software&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Project 7: VM I: Stack Arithmetic&lt;/strong>
&lt;ul>
&lt;li>Building the first part of a Virtual Machine Translator to translate virtual machine language into assembly code. This first part implements the translation of stack arithmetic and memory access operations.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 8: VM II: Program Control&lt;/strong>
&lt;ul>
&lt;li>Completion of the Virtual Machine Translator by including flow control and function call and return operations. This enables the use of a higher-level Virtual Machine (VM) abstraction based on a stack, similar to modern software implementations that use two-tier compilers, such as Java.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 9: High-Level Language&lt;/strong>
&lt;ul>
&lt;li>Writing a program in Jack, a simple high-level object-oriented language with a Java-like syntax. I implemented the game &lt;a href="https://en.wikipedia.org/wiki/Breakout_%28video_game%29" target="_blank" rel="noopener">Breakout&lt;/a>. To run a Jack program on the Hack computer using the previous VM translator, it must be compiled into VM code. This is developed in the following projects.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 10: Compiler I: Syntax Analysis&lt;/strong>
&lt;ul>
&lt;li>Building a syntax analyser to parse arbitray Jack programs. This uses a recursive algorithm to output an XML file that captures the semantic structure of the program.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 11: Compiler II: Code Generation&lt;/strong>
&lt;ul>
&lt;li>Completing the Jack compiler to compile arbitrary Jack code into VM code that runs on the virtual machine developed in Projects 7 and 8.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Project 12: Operating System&lt;/strong>
&lt;ul>
&lt;li>Implementation of the final component required to run Jack programs on the Hack computer; the Operating System. This comprises of eight classes written in Jack:
&lt;ul>
&lt;li>Sys: Handles system booting and program executation utilities.&lt;/li>
&lt;li>Memory: Handles memory allocation and deallocation operations.&lt;/li>
&lt;li>Math: Provides basic mathematical operations in an efficient manner.&lt;/li>
&lt;li>Screen: Handles graphical screen output.&lt;/li>
&lt;li>Output: Handles text-based output.&lt;/li>
&lt;li>Keyboard: Handles user input from the keyboard.&lt;/li>
&lt;li>String: Implements a String type and basic string processing operations.&lt;/li>
&lt;li>Array: Implements the Array type and enables construction and disposal of arrays.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Reinforcement Learning to Play Doom</title><link>https://adamjelley.github.io/project/doomrl/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/doomrl/</guid><description>&lt;img src="../../uploads/PPO_VizdoomCorridor-v0_ShootingReward_1eps.gif" alt="PPO agent on Vizdoom Corridor.">
&lt;p>A project to apply reinforcement learning to play Doom. Uses &lt;a href="https://stable-baselines3.readthedocs.io/en/master/index.html" target="_blank" rel="noopener">StableBaselines3&lt;/a> implementations of RL algorithms on &lt;a href="http://vizdoom.cs.put.edu.pl/" target="_blank" rel="noopener">ViZDoom&lt;/a> using the &lt;a href="https://github.com/shakenes/vizdoomgym" target="_blank" rel="noopener">ViZDoomGym&lt;/a> wrapper. Key takeaway: reward shaping is key!&lt;/p></description></item><item><title>Advent Of Code</title><link>https://adamjelley.github.io/project/adventofcode/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/adventofcode/</guid><description>&lt;p>My solutions to &lt;a href="https://adventofcode.com" target="_blank" rel="noopener">Advent Of Code&lt;/a> 2021, earning the full 50*. Time well-spent in the first year of my PhD while not knowing what to work on!&lt;/p></description></item><item><title>Reinforcement Learning Reimplementations</title><link>https://adamjelley.github.io/project/rlimplementations/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/rlimplementations/</guid><description>&lt;p>Reimplementations of various reinforcement learning algorithms:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/AdamJelley/Actor-Critic-Agents" target="_blank" rel="noopener">Actor-critic&lt;/a> (including policy gradients)&lt;/li>
&lt;li>&lt;a href="https://github.com/AdamJelley/Deep-Q-Learning-Agents" target="_blank" rel="noopener">Value-based&lt;/a> (Q-learning)&lt;/li>
&lt;li>&lt;a href="https://github.com/AdamJelley/Curiosity-A3C-Agent" target="_blank" rel="noopener">Unsupervised&lt;/a> (reward-free i.e. curiosity)&lt;/li>
&lt;/ul></description></item><item><title>Football Match Prediction</title><link>https://adamjelley.github.io/project/footballprediction/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/footballprediction/</guid><description>&lt;p>My football match prediction webapp running live on a Sunday evening in November 2019. This is a picture of an early version, but unfortunately is the only picture I still have&amp;hellip; I later improved the performance and UI and got to around 70% accuracy over win/lose/draw predictions, but eventually came up against the hard truth that football games have a substantial component of randomness that is impossible to predict before the match begins, no matter how much you improve your algorithm and data!&lt;/p>
&lt;h1 id="project-overview">Project Overview&lt;/h1>
&lt;p>The aim of this project was to predict the outcome of football matches. The final version provided up to date predictions of all Premier League and Championship games, but is no longer running due to the cost of the API data and hosting the webapp.&lt;/p>
&lt;h1 id="data">Data&lt;/h1>
&lt;p>The data comes from &lt;a href="https://www.api-football.com/" target="_blank" rel="noopener">api-football&lt;/a>, for which the various data feeds are well documented &lt;a href="https://www.api-football.com/documentation#documentation-v239-api-architecture" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>In the current version, we used the match fixtures API to get historical match results for the Premier League and Championship for the last 10 years, as well as to get the upcoming fixtures for the next week.&lt;/p>
&lt;h1 id="flow">Flow&lt;/h1>
&lt;p>The first python recipe (&lt;a href="recipe:compute_Leagues">compute_Leagues&lt;/a>) is used to get the available leagues and their corresponding IDs from the API. This data is cleaned and filtered down to the leagues of interest to give the &lt;a href="dataset:Leagues_prepared_filtered">Leagues_prepared_filtered&lt;/a> dataset.&lt;/p>
&lt;p>These league IDs are then used to get all the corresponding &lt;a href="dataset:Fixtures_prepared">historical fixtures&lt;/a> (from beginning of 2010 season to yesterday inclusive), as well as the &lt;a href="dataset:Upcoming_Fixtures_prepared">upcoming fixtures&lt;/a> (from today for the next week inclusive), from the API.&lt;/p>
&lt;p>We then use a custom developed &lt;a href="recipe:compute_Team_Elo_Ranks">plugin&lt;/a> to compute the Elo ratings (wikipedia: &lt;a href="https://en.wikipedia.org/wiki/Elo_rating_system" target="_blank" rel="noopener">Elo Ratings&lt;/a>) for each team over the fixture history. Elo ratings originate from chess but also provide an accurate way of ranking football teams over time. We extract the most recent Elo ratings for each team from the history using &lt;a href="recipe:compute_Latest_Team_Elo_Ranks">SQL&lt;/a> which can be &lt;a href="recipe:compute_Upcoming_Fixtures_EloFeatures">joined&lt;/a> to the upcoming fixtures.&lt;/p>
&lt;p>We trained a simple &lt;a href="saved_model:STX882mM">logistic regression &lt;/a> algorithm on these ranks from the fixtures history to predict the outcome of the game. This model is then used to score the &lt;a href="dataset:Upcoming_Fixtures_prepared">upcoming fixtures&lt;/a> to get the model &lt;a href="dataset:Upcoming_Fixtures_EloFeatures_scored">predictions&lt;/a> for the next week of fixtures. We also evaluate the model on the historical fixtures so we can trace the accuracay of &lt;a href="dataset:Historical_Fixtures_Evaluated">historical predictions&lt;/a> as well.&lt;/p>
&lt;h1 id="automation">Automation&lt;/h1>
&lt;p>There are currently 5 scenarios: 4 of which are run daily in sequence starting at 0200 UTC, one of which is run weekly on a Sunday at 0400 UTC (in addition to one just to re-build the entire flow from scratch) which are used to automate the project:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Compute Latest Ranks (Daily, 0200 UTC)&lt;/strong>
This updates the historical fixtures table with the latest results, recalculates the Elo ranks for the entire history and then extracts the most recent Elo rank for each team.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Get Upcoming Fixtures (Daily, after Compute Latest Ranks completes)&lt;/strong>
This gets the upcoming fixtures for the next week including the current day.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Predict Historical Fixtures (Daily, after Get Upcoming Fixtures completes)&lt;/strong>
This uses the model to evaluate all historical fixtures (get predictions and compare them against the result to see if they were true or false).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Predict Upcoming Fixtures (Daily, after Predict Historical Fixtures completes)&lt;/strong>
This uses the model to predict all upcoming fixtures.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Retrain Model (Weekly, Sunday 0400 UTC)&lt;/strong>
This retrains the model with the complete history of fixtures (including the latest week of fixture results).&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="webapp">Webapp&lt;/h1>
&lt;p class="text-center">
&lt;a href="https://dsproj1.dataiku.com/public-webapps/football-predictions">Web Application&lt;/a>
&lt;/p>
&lt;p>The predictions for the upcoming fixtures and also for the historical fixtures are served via a basic Flask &lt;a href="web_app:JidtqGs">webapp&lt;/a>. The webapp provides an interface with buttons to get either the upcoming or historical fixtures. These buttons use JS to access a python backend to get the requested data.&lt;/p>
&lt;h1 id="dashboard">Dashboard&lt;/h1>
&lt;p>The predictions are also served via a &lt;a href="dashboard:Hsi5bIw">dashboard&lt;/a>. The dashboard has three slides:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>The first slide shows the current team rankings, the upcoming fixture predictions and the historical fixture predictions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The second slide shows an overview of the model, including training information, model performance metrics, the confusion matrix and the prediction density distributions.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The third slide contains the web application described above.&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Invisibility and Maxwell's Equations</title><link>https://adamjelley.github.io/project/invisibility/</link><pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate><guid>https://adamjelley.github.io/project/invisibility/</guid><description>&lt;p>We investigate the origin of the form invariance of Maxwellâs Equations and see how this relates to the theory of transformation optics, in which a particular geometry is related to the equivalent electromagnetic properties required in Euclidian space to create the geometry. This idea is used to reformulate transformation optics in the more natural language of differential geometry and to derive the electromagnetic properties associated with arbitrary transformations using these techniques. The theory of transformation optics is then generalised to non-linear electromagnetic media and to a spacetime formulation.&lt;/p></description></item></channel></rss>